# 5. Saving User Input: Testing the Database


## TOC (with 24 pages in Chinese edition)

- 5.1. Wiring Up Our Form to Send a POST Request
- 5.2. Processing a POST Request on the Server
- 5.3. Passing Python Variables to Be Rendered in the Template
- 5.4. Three Strikes and Refactor
- 5.5. The Django ORM and Our First Model
- 5.6. Saving the POST to the Database
- 5.7. Redirect After a POST
- 5.8. Rendering Items in the Template
- 5.9. Creating Our Production Database with migrate
- 5.10. Recap


## Why not be smarter to handle all those problems at once?

1. the point of TDD is to allow you to do one thing at a time, when you need to. 

be deliberately short-sighted, and at any given moment only do what was necessary to get the functional tests a little further.

2. how TDD can support an iterative style of development.

​it may not be the quickest route, but you do get there in the end. 

3. to introduce new concepts one at a time

But for now let’s plough on mindlessly and just do what the tests tell us to.


## What dose a standard HTML POST request look like? (And what other method could be used later?)

To get our browser to send a POST request, we need to do two things:

1. Give the `<input>` element a `name=` attribute. 

This `name` is the key in `response = self.client.post('/', data={'item_text': 'A new list item'})`.

2. Wrap this `<input>` in a `<form>` tag with method="POST".

So in tests.py we can use `client`'s `post` method.

A little boring, but also nice and easy to deliver.

​HTML5 and JavaScript


*lists/templates/home.html*
```html
<h1>Your To-Do list</h1>

<form method="POST">
<!--# Note here method can be "GET", "POST", "PUT".etc-->
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    <!--Here `name` is the key of various input data. i.e. `data=dict{"item_text": "something inputed here"}`-->
</form>

<table id="id_list_table">
```

*lists/tests.py*
```python
def test_can_save_a_POST_request(self):
    # To do a POST, we call self.client.post, and as you can see it takes a data argument which contains the form data we want to send.
    response = self.client.post('/', data={'item_text': 'A new list item'})
    # check that the text from our POST request ends up in the rendered HTML.
    self.assertIn('A new list item', response.content.decode())
```

*lists/views.py*
```python
from django.http import HttpResponse
from django.shortcuts import render

def home_page(request):
    if request.method == 'POST':
        return HttpResponse(request.POST['item_text']) # it’s not
        # really what we want. What we really want to do is add 
        # the POST submission to the table in the home page template.
    return render(request, 'home.html')
```


## When a functional test fails with an unexpected failure, what can we do?

there are several things we can do to debug it:

- Add print statements, to show, for example, what the current page text is.
- Improve the error message to show more info about the current state.
- Manually visit the site yourself.
- Use time.sleep to pause the test during execution.[1]

the time.sleep option is one I find myself using very often.


## What is CSRF - Cross-Site Request Forgery exploit?

> Cross-site request forgery, also known as one-click attack or session riding and abbreviated as CSRF (sometimes pronounced sea-surf[1]) or XSRF, 
> 
> is a type of malicious exploit of a website where unauthorized commands are transmitted from a user that the web application trusts.[2] 
> 
> There are many ways in which a malicious website can transmit such commands; specially-crafted image tags, hidden forms, and JavaScript XMLHttpRequests, for example, can all work without the user's interaction or even knowledge. 
> 
> Unlike cross-site scripting (XSS), which exploits the trust a user has for a particular site, CSRF exploits the trust that a site has in a user's browser. 

from [wikipedia](https://en.wikipedia.org/wiki/Cross-site_request_forgery)

> CSRF可以做什么？
> 
> 你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。
> 
> CSRF的原理
>
> 下图简单阐述了CSRF攻击的思想：　
> ![](https://ws2.sinaimg.cn/large/006tKfTcly1ftwc9dju86j30t80ghjvw.jpg)

from [浅谈CSRF攻击方式](https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html)


## On the module of Security, what book is recommended?

Ross Anderson’s [Security Engineering](http://www.cl.cam.ac.uk/~rja14/book.html). 

It’s quite light on pure crypto, but it’s absolutely full of interesting discussions of unexpected topics like lock picking, forging bank notes, inkjet printer cartridge economics, and spoofing South African Air Force jets with replay attacks. 

It’s a huge tome, about three inches thick, and I promise you it’s an absolute page-turner.


## Is the curly-bracket/percent syntax, {% ... %} a template tag?

```html
{% csrf_token %}
```

Django’s CSRF protection involves placing a little auto-generated token into each generated form, to be able to identify POST requests as having come from the original site. 

Django will substitute that during rendering with an `<input type="hidden">` containing the CSRF token.

#### Token

Token, an object (in software or in hardware) which represents the right to perform some operation:
- Tokenization (data security), the process of substituting a sensitive data element
- Token, an object used in Petri net theory
- Access token, a system object representing the subject of access control operations
- Session token, a unique identifier of an interaction session
- Security token or hardware token, authentication token or cryptographic token, a physical device for computer authentication
- Token ring, a network technology in which a token circles in a logical ring
- Invitation token, in an invitation system

from [wikipedia](https://en.wikipedia.org/wiki/Token)


## How to pass variables in `view.py` to html templates?

1. Here is what we want to test: a newly inputed item is in page refreshed.

*lists/tests.py*
```python
    def test_can_save_a_POST_request(self):
        response = self.client.post('/', data={'item_text': 'A new list item'})
        self.assertIn('A new list item', response.content.decode())
        self.assertTemplateUsed(response, 'home.html')
```

2. Add that content to html template with a python variable name.

*lists/templates/home.html*
```python
<body>
    <h1>Your To-Do list</h1>
    <form method="POST">
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
        {% csrf_token %}
    </form>

    <table id="id_list_table">
        @*i<tr><td>{{ new_item_text }}</td></tr>  *
    </table>
</body>
```

3. Bend the variable name in html template with actual data content. And render it to that template with a dictionary mapping.

*lists/views.py (ch05l009)*
```python
def home_page(request):
    return render(request, 'home.html', {
        # 'new_item_text': request.POST['item_text'], # what if we 
        # are GET to home page without 'item_text' POST? So:
        'new_item_text': request.POST.get('item_text', ''),
    })
```

## Why saying improving the error message is probably the most constructive technique?
 
Because those improved error messages stay around to help debug any future errors.

functional_tests.py
```python
self.assertTrue(
    any(row.text == '1: Buy peacock feathers' for row in rows),
    f"New to-do item did not appear in table. Contents were:\n{table.text}"
)
```

```commandline
AssertionError: False is not true : New to-do item did not appear in table. Contents were:
Buy peacock feathers
```


## Why that you should always be very worried whenever you think you’re being clever?

Because what you’re probably being is overcomplicated. 

look at this example, using `any` and `assertTrue`, or using `assertIn` and list comprehension.

functional_tests.py
```python
self.assertTrue(
    any(row.text == '1: Buy peacock feathers' for row in rows),
    f"New to-do item did not appear in table. Contents were:\n{table.text}"
)
# the output:
# AssertionError: False is not true : New to-do item did not appear in table. Contents were:
# Buy peacock feathers
```

functional_tests.py
```python
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
# the output;    
# AssertionError: '1: Buy peacock feathers' not found in ['Buy peacock feathers']
```


## What justifies moving from an implementation where we "cheat" to one we’re happy with?

### eliminate duplication

One methodology is **eliminate duplication**: 

if your test uses a magic constant (like the "1:" in front of our list item), and your application code also uses it, that counts as duplication, so it justifies refactoring. Removing the magic constant from the application code usually means you have to stop cheating.

### triangulation

I find that leaves things a little too vague, so I usually like to use a second technique, which is called **triangulation**: 

if your tests let you get away with writing "cheating" code that you’re not happy with, like returning a magic constant, write another test that forces you to write some better code. That’s what we’re doing when we extend the FT to check that we get a "2:" when inputting a second list item.


## What is Red/Green/Refactor?

The unit-test/code cycle is sometimes taught as Red, Green, Refactor:

1. Start by writing a unit test which fails (Red).
2. Write the simplest possible code to get it to pass (Green), even if that means cheating.
3. Refactor to get to better code that makes more sense.


## Don't repeat yourself

From [Wikipedia](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)

The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system".

### DRY vs WET solutions
Violations of DRY are typically referred to as WET solutions, which is commonly taken to stand for either 
- "write everything twice", 
- "we enjoy typing" or 
- "waste everyone's time". 

[Dont Repeat Yourself in C2](http://wiki.c2.com/?DontRepeatYourself)

### Where does wiki origin from?

[WikiWikiWeb](https://en.wikipedia.org/wiki/WikiWikiWeb) wikipedia

Its front page:

http://wiki.c2.com/?FrontPage



In wikiwikiweb, there is a [Extreme Programming Roadmap](http://wiki.c2.com/?ExtremeProgrammingRoadmap)


## What is 'code smell'?

From [Wikipedia](https://en.wikipedia.org/wiki/Code_smell), the free encyclopedia

In computer programming, a code smell is any characteristic in the source code of a program that possibly indicates a deeper problem.[1][2] Determining what is and is not a code smell is subjective, and varies by language, developer, and development methodology.

[CodeSmell](https://martinfowler.com/bliki/CodeSmell.html)
by Martin Fowler

9 February 2006

A code smell is a surface indication that usually corresponds to a deeper problem in the system. The term was first coined by Kent Beck while helping me with my Refactoring book.

The quick definition above contains a couple of subtle points. 

Firstly a smell is by definition something that's quick to spot - or sniffable as I've recently put it. A long method is a good example of this - just looking at the code and my nose twitches if I see more than a dozen lines of java.

The second is that smells don't always indicate a problem. Some long methods are just fine. You have to look deeper to see if there is an underlying problem there - smells aren't inherently bad on their own - they are often an indicator of a problem rather than the problem themselves.

One of the nice things about smells is that it's easy for inexperienced people to spot them, even if they don't know enough to evaluate if there's a real problem or to correct them. I've heard of lead developers who will pick a "smell of the week" and ask people to look for the smell and bring it up with the senior members of the team. Doing it one smell at a time is a good way of gradually teaching people on the team to be better programmers.

### I need somewhere to practice this best practice.


## Three Strikes And You Refactor

### Stages of refactoring?

The first time you do something, you just do it.
The second time you do something similar, you wince at the duplication, but you do the duplicate thing anyway.
The third time you do something similar, you refactor.

### Why wait for third time?

You especially want to apply this RuleOfThree when the first two cases aren't enough to really understand what is common and what is unique about the uses.

> However, refactoring code to eliminate duplication takes time, which might be better spent on other tasks. Additionally, choosing a good design to refactor code into becomes easier when there are more examples of duplicated code to see patterns in. With three examples of similar code, it is easier than with two examples to see what parts of the code should be abstracted and what parts should be the same in all cases. 
from [wikipedia](https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming))


Also, when you have three cases, you can be fairly confident that you'll have a fourth. 

As Charles Petzold puts it, "Three or more? Use a for!"


## What is in Django's ORM?

An Object-Relational Mapper (ORM) is a layer of abstraction for data stored in a database with tables, rows, and columns. It lets us work with databases using familiar object-oriented metaphors which work well with code. Classes map to database tables, attributes map to columns, and an individual instance of the class represents a row of data in the database.

lists/tests.py
```python
from lists.models import Item
[...]

class ItemModelTest(TestCase):

    def test_saving_and_retrieving_items(self):
        first_item = Item()
        first_item.text = 'The first (ever) list item'
        first_item.save()

        second_item = Item()
        second_item.text = 'Item the second'
        second_item.save()
        
# You can see that creating a new record in the database is a relatively simple matter of creating an object, assigning some attributes, and calling a .save() function. 

        saved_items = Item.objects.all()
        
# Django also gives us an API for querying the database via a class attribute, .objects, and we use the simplest possible query, .all(), which retrieves all the records for that table. 

        self.assertEqual(saved_items.count(), 2)
        
# The results are returned as a list-like object called a QuerySet, from which we can extract individual objects, and also call further functions, like .count(). 

        first_saved_item = saved_items[0]
        second_saved_item = saved_items[1]
        self.assertEqual(first_saved_item.text, 'The first (ever) list item')
        self.assertEqual(second_saved_item.text, 'Item the second')
        
# We then check the objects as saved to the database, to check whether the right information was saved.
```


## What are the roles of models.py and 'migration' system?

In Django, the ORM’s job is to model the database, but there’s a second system that’s in charge of actually building the database called migrations. Its job is to give you the ability to add and remove tables and columns, based on changes you make to your models.py files.

One way to think of it is as a version control system for your database. 

这里留了伏笔。我没有想明白，这里的类比关系。git在本地记录，git push才是建立？

As we’ll see later, it comes in particularly useful when we need to upgrade a database that’s deployed on a live server.


## What did the two `makemigrations` make in migration folder?

lists/models.py
```python
from django.db import models

class Item(models.Model):
    pass
```

lists/migrations/0001_initial.py
```python
from __future__ import unicode_literals

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Item',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
            ],
        ),
    ]
```

lists/models.py
```python
class Item(models.Model):
    text = models.TextField(default='') # if no default value, django says:
    # You are trying to add a non-nullable field 'text' to item without a default; we
    # can't do that (the database needs something to populate existing rows).
```

lists/migrations/0002_item_text.py
```python
# -*- coding: utf-8 -*-
# Generated by Django 1.11.14 on 2018-08-02 06:11
from __future__ import unicode_literals

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('lists', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='item',
            name='text',
            field=models.TextField(default=''),
        ),
    ]
```


## Why each test should only test one thing?

The reason is that it makes it easier to track down bugs. 

Having multiple assertions in a test means that, if the test fails on an early assertion, you don’t know what the status of the later assertions is. 

As we’ll see in the next chapter, if we ever break this view accidentally, we want to know whether it’s the saving of objects that’s broken, or the type of response. 


## What is the typical structure for a unit test?

Setup, Exercise, Assert

lists/tests.py
```python
class HomePageTest(TestCase):
    [...]

    def test_displays_all_list_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        response = self.client.get('/')

        self.assertIn('itemey 1', response.content.decode())
        self.assertIn('itemey 2', response.content.decode())
```


## What is the difference of `{{...}}` and `{%...%}` template tags?

The notation is {{ ... }}, which displays the object as a string.



## What do `return render()` perform during `home_page` function's evolution?

### Round No.1: simply `render` a home page.

lists/views.py
```python
from django.http import HttpResponse
from django.shortcuts import render

def home_page(request):
    if request.method == 'POST':
        return HttpResponse(request.POST['item_text'])
    return render(request, 'home.html')
```

### Round No.2: to pass the POST parameter to the template.

```python
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST['item_text'],
    })
```

### Round No.3: POST as well as normal case

Using dict.get(key, default_value)

lists/views.py
```python
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
```

### Round No.4: with writing database

lists/views.py
```python
from django.shortcuts import render
from lists.models import Item

def home_page(request):
    item = Item()
    item.text = request.POST.get('item_text', '')
    item.save()

    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
```

### Round No.5: refactor the duplicated expression

lists/views.py
```python
from django.shortcuts import render
from lists.models import Item

def home_page(request):
    item = Item()
    item.text = request.POST.get('item_text', '')
    item.save()

    return render(request, 'home.html', {
        'new_item_text': item.text
    })
```

### Round No.6: Another way (`Item.objects.create`) to write in database.

lists/views.py
```python
def home_page(request):
    if request.method == 'POST':
        new_item_text = request.POST['item_text']  
        Item.objects.create(text=new_item_text)  
    else:
        new_item_text = ''  

    return render(request, 'home.html', {
        'new_item_text': new_item_text,  
    })
```

### Round No.7: After POST, redirect to homepage

lists/views.py (ch05l028)
```python
from django.shortcuts import redirect, render
from lists.models import Item

def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    return render(request, 'home.html')
```
### Round No.8: Gather objects from database, passing them to template.

ists/views.py
```python
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
```

---
lastupdated at 2018-08-06 16:08:37
