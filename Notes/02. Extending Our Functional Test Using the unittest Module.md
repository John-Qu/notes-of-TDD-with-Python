# 2. Extending Our Functional Test Using the unittest Module


## Why use a to-do list as an concrete example?

Why not blog, forums, or polls?

> At its most basic it is very simple indeed—​just a list of text strings—​so it’s easy to get a "minimum viable" list app up and running. 
> But it can be extended in all sorts of ways—​different persistence models, adding deadlines, reminders, sharing with other users, and improving the client-side UI.
> But the point is that it should allow me to demonstrate all of the main aspects of web programming, and how you apply TDD to them.


## What are the other terms to describe "functional test"?

FT-functional test, can be a sort of specification for your application. It tends to track what you might call a User Story, and follows how the user might work with a particular feature and how the app should respond to them.

Functional Test == Acceptance Test == End-to-End Test (== Black box test)


## Is virtuously peppering code with nice descriptive comments always a good practice?

> “Harry, we have a word for comments. We call them lies.”

for example:
```python
# increment wibble by 1
wibble += 1
```
Not only is it pointless, but there’s a danger that you’ll forget to update the comments when you update the code, and they end up being misleading. 


## What annoyances do standard library 'unittest' deal with for us?

Firstly, the message "AssertionError" isn’t very helpful

One option would be to use the second parameter to the assert keyword, something like:

```python
assert 'To-Do' in browser.title, "Browser title was " + browser.title
```

Secondly, it’s left a Firefox window hanging around the desktop

We could use a try/finally to clean up the old Firefox window. 


## What are the things to notice in unittest version of test file?

### Using class to organize actions.

Which inherit from `unittest.TestCase`.

### Using nice descriptive names for `test_` method.

There can be many of them per class, which can be run by the test runner.

### Using `setUp` and `tearDown` to start and stop our browser.

`setUp` and `tearDown` are special methods which get run before and after each test. 

Like a try/except, tearDown will run even if there’s an error during the test itself. But if there is an exception in `setUp`, then `tearDown` doesn't run.

### Using `assertIn()` method instead of `assert sth in sth` statement.

`unittest` provides lots of helper functions like this to make test assertions, in [unittest document](https://docs.python.org/3.6/library/unittest.html#assert-methods):

Method	Checks that	New in
assertEqual(a, b)	a == b	 
assertNotEqual(a, b)	a != b	 
assertTrue(x)	bool(x) is True	 
assertFalse(x)	bool(x) is False	 
assertIs(a, b)	a is b	3.1
assertIsNot(a, b)	a is not b	3.1
assertIsNone(x)	x is None	3.1
assertIsNotNone(x)	x is not None	3.1
assertIn(a, b)	a in b	3.1
assertNotIn(a, b)	a not in b	3.1
assertIsInstance(a, b)	isinstance(a, b)	3.2
assertNotIsInstance(a, b)	not isinstance(a, b)

### using `self.fail()` as a reminder to finish the test.

### Calling `unittest.main()`

It launches the unittest test runner, which will automatically find test classes and methods in the file and run them.

### Using `warnings='ignore'` to suppress a superfluous ResourceWarning


## Report a typo error to Harry.
Hello, Harry. Found a typo error maybe. 
In "note that they’re a bit like a `try/except`",  do you mean `try/finally` as you mentioned above in "And we could also use a `try/finally` to clean up the old Firefox window."?
`tearDown()` is run anyway, this feather sound like what `finally` do, not `except` do.

---
2018-07-30 16:17:27
